<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TeXLa: texla.Parser.Parser.Parser Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="texla-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">TeXLa
   &#160;<span id="projectnumber">0.9</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>texla</b></li><li class="navelem"><b>Parser</b></li><li class="navelem"><b>Parser</b></li><li class="navelem"><a class="el" href="classtexla_1_1Parser_1_1Parser_1_1Parser.html">Parser</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classtexla_1_1Parser_1_1Parser_1_1Parser-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">texla.Parser.Parser.Parser Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa60009122c54ff992915770470fefbe8"><td class="memItemLeft" align="right" valign="top"><a id="aa60009122c54ff992915770470fefbe8"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>__init__</b> (self, configs)</td></tr>
<tr class="separator:aa60009122c54ff992915770470fefbe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb55891b1d2f77a2e3aeeeb7f7e63550"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtexla_1_1Parser_1_1Parser_1_1Parser.html#afb55891b1d2f77a2e3aeeeb7f7e63550">parse</a> (self, tex)</td></tr>
<tr class="separator:afb55891b1d2f77a2e3aeeeb7f7e63550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f65437398ebf3111c428747fdac9489"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtexla_1_1Parser_1_1Parser_1_1Parser.html#a7f65437398ebf3111c428747fdac9489">parse_sections</a> (self, tex, level, parent_block, options)</td></tr>
<tr class="separator:a7f65437398ebf3111c428747fdac9489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c403acf107ba47795b70391db7e4bd4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtexla_1_1Parser_1_1Parser_1_1Parser.html#a4c403acf107ba47795b70391db7e4bd4">parse_instructions</a> (self, tex, parent_block, options)</td></tr>
<tr class="separator:a4c403acf107ba47795b70391db7e4bd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5a596144e7be79cbca63d05dce99f06"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtexla_1_1Parser_1_1Parser_1_1Parser.html#ae5a596144e7be79cbca63d05dce99f06">parse_enviroment</a> (self, tex, parent_block, options)</td></tr>
<tr class="separator:ae5a596144e7be79cbca63d05dce99f06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee9adc1fcfa4c8194e37552124f67848"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtexla_1_1Parser_1_1Parser_1_1Parser.html#aee9adc1fcfa4c8194e37552124f67848">parse_math</a> (self, tex, parent_block, options)</td></tr>
<tr class="separator:aee9adc1fcfa4c8194e37552124f67848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac878c2e3e4690f9975ccf541b11796b5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtexla_1_1Parser_1_1Parser_1_1Parser.html#ac878c2e3e4690f9975ccf541b11796b5">parse_command</a> (self, tex, parent_block, options)</td></tr>
<tr class="separator:ac878c2e3e4690f9975ccf541b11796b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ce55a1ea4d024ff77ce3a3718b76bbd"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtexla_1_1Parser_1_1Parser_1_1Parser.html#a2ce55a1ea4d024ff77ce3a3718b76bbd">parse_commands_group</a> (self, tex, parent_block, options)</td></tr>
<tr class="separator:a2ce55a1ea4d024ff77ce3a3718b76bbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66a08e68dd0a879d09ed5be4b41eb4b9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtexla_1_1Parser_1_1Parser_1_1Parser.html#a66a08e68dd0a879d09ed5be4b41eb4b9">parse_letter_command</a> (self, tex, parent_block, options)</td></tr>
<tr class="separator:a66a08e68dd0a879d09ed5be4b41eb4b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4a46e7760e444cd77edf24053eb2cad"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtexla_1_1Parser_1_1Parser_1_1Parser.html#af4a46e7760e444cd77edf24053eb2cad">parse_special_character</a> (self, tex, parent_block, options)</td></tr>
<tr class="separator:af4a46e7760e444cd77edf24053eb2cad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5273483c94bc329e6ec18d67967ce4a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtexla_1_1Parser_1_1Parser_1_1Parser.html#af5273483c94bc329e6ec18d67967ce4a">parse_plain_text</a> (self, tex, parent_block)</td></tr>
<tr class="separator:af5273483c94bc329e6ec18d67967ce4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fa931c1a8b0b570977fb5c311ea9ec0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtexla_1_1Parser_1_1Parser_1_1Parser.html#a7fa931c1a8b0b570977fb5c311ea9ec0">call_parser_hook</a> (self, hook, type, tex, parent_block, params={})</td></tr>
<tr class="separator:a7fa931c1a8b0b570977fb5c311ea9ec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ae261ebc4805082d9e913ac94fddbbf2c"><td class="memItemLeft" align="right" valign="top"><a id="ae261ebc4805082d9e913ac94fddbbf2c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>configs</b></td></tr>
<tr class="separator:ae261ebc4805082d9e913ac94fddbbf2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b3170987364bf71a42581ff7d768002"><td class="memItemLeft" align="right" valign="top"><a id="a7b3170987364bf71a42581ff7d768002"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>doc_data</b></td></tr>
<tr class="separator:a7b3170987364bf71a42581ff7d768002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64d8a35b7496d8dfd1046cd74ea91500"><td class="memItemLeft" align="right" valign="top"><a id="a64d8a35b7496d8dfd1046cd74ea91500"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>root_block</b></td></tr>
<tr class="separator:a64d8a35b7496d8dfd1046cd74ea91500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa71568a987d222cca941991fcb7d0f92"><td class="memItemLeft" align="right" valign="top"><a id="aa71568a987d222cca941991fcb7d0f92"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>tree_explorer</b></td></tr>
<tr class="separator:aa71568a987d222cca941991fcb7d0f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7fa931c1a8b0b570977fb5c311ea9ec0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fa931c1a8b0b570977fb5c311ea9ec0">&sect;&nbsp;</a></span>call_parser_hook()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def texla.Parser.Parser.Parser.call_parser_hook </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>hook</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>parent_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>params</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">This function checks if the required parser_hook
is avaiable, if not it calls th default hook.
The function ask for type of call (env or cmd)
to be able of asking the right default hooks,
in case the hook in not avaiable.
Params is a dictionary of options for the parser. It
usually contains che env or cmd parsed and if it's
starred.
It returns directly the output of parser_hook.
</pre> 
</div>
</div>
<a id="afb55891b1d2f77a2e3aeeeb7f7e63550"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb55891b1d2f77a2e3aeeeb7f7e63550">&sect;&nbsp;</a></span>parse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def texla.Parser.Parser.Parser.parse </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Entry point for parsing.
The DocumentBlock is created and all the
parse chain is started from parse_sections.
The function returns the root_block,
which contains all the parsed tree blocks.</pre> 
</div>
</div>
<a id="ac878c2e3e4690f9975ccf541b11796b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac878c2e3e4690f9975ccf541b11796b5">&sect;&nbsp;</a></span>parse_command()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def texla.Parser.Parser.Parser.parse_command </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>parent_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">This function handles the parsing of normal
commands. It catches the command's name and if it's
starred. Removed the \cmd part, the tex is passed
to the right parser_hook that manages the real
parsing of commands options. The parser_hook decides
also if the content of the command must be parsed
recursively.
It returns the block and the left tex that must
be parsed by another cycle of parse_instructions()
</pre> 
</div>
</div>
<a id="a2ce55a1ea4d024ff77ce3a3718b76bbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ce55a1ea4d024ff77ce3a3718b76bbd">&sect;&nbsp;</a></span>parse_commands_group()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def texla.Parser.Parser.Parser.parse_commands_group </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>parent_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">This function handles the group of commands created
with the syntax {...}. It's used for the formatting
commands.
</pre> 
</div>
</div>
<a id="ae5a596144e7be79cbca63d05dce99f06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5a596144e7be79cbca63d05dce99f06">&sect;&nbsp;</a></span>parse_enviroment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def texla.Parser.Parser.Parser.parse_enviroment </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>parent_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">This function handles the parsing of environments.
It parses the name of the environment and if it's starred.
Then EnvironmentParser.get_environment() is used to extract
the complete environment, handling nested envs.
The content is sent to parser_hook for the specific parsing.
The parser_hook decides also if the content of the env
must be parsed recursively.
A new block is created and returned with the tex
remained to parse.
</pre> 
</div>
</div>
<a id="a4c403acf107ba47795b70391db7e4bd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c403acf107ba47795b70391db7e4bd4">&sect;&nbsp;</a></span>parse_instructions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def texla.Parser.Parser.Parser.parse_instructions </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>parent_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">This function is the MAIN ENTRY POINT for parsing.
It scan the tex from left to right. It searches for
\\ or $. When an instruction is found (a pattern starting
with \\ or $), the right parser function is called.
These functions take care to parse the command,
create the block calling parser_hooks, and to return
the block and the tex left to parse. Then the remaining
tex starts a new cycle in parse_instructions() recursively.
It returnes a list of parsed blocks.

The categories of instrucions parsed are:
-math: starts with $, $$ or \[ \(
-environments: (start with \begin)
-letters commands: they are special commands
    listed in letters_commands. They are
    parsed separately
-normal commands: like \cmd{text}
</pre> 
</div>
</div>
<a id="a66a08e68dd0a879d09ed5be4b41eb4b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66a08e68dd0a879d09ed5be4b41eb4b9">&sect;&nbsp;</a></span>parse_letter_command()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def texla.Parser.Parser.Parser.parse_letter_command </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>parent_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">'
This function handles special commands for accented
or modified letters.
They are special commands because they don't need a {}
and they act directly on the next letter.
Examples:
\'a: accented letter
\`a: grave accent
\~a \=a \^a other changes on the letter

The function parse that commands and call
parser_hook as the normal parse_command() function.
Althought, the letter influenced by the command is
inserted in a {} so that special command could
be treated like normal commands with hooks.
It returns the block and the left tex to parse.
</pre> 
</div>
</div>
<a id="aee9adc1fcfa4c8194e37552124f67848"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee9adc1fcfa4c8194e37552124f67848">&sect;&nbsp;</a></span>parse_math()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def texla.Parser.Parser.Parser.parse_math </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>parent_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">This function handles the parsing of math commands:
$..$, $$..$$, \[..\], \(..\). The matched math
is inserted in "display_math" or "inline_math" block.
The function returnes the block and left_tex.
</pre> 
</div>
</div>
<a id="af5273483c94bc329e6ec18d67967ce4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5273483c94bc329e6ec18d67967ce4a">&sect;&nbsp;</a></span>parse_plain_text()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def texla.Parser.Parser.Parser.parse_plain_text </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>parent_block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">This function create the block for plain text.
It doesn't return any left tex.
</pre> 
</div>
</div>
<a id="a7f65437398ebf3111c428747fdac9489"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f65437398ebf3111c428747fdac9489">&sect;&nbsp;</a></span>parse_sections()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def texla.Parser.Parser.Parser.parse_sections </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>parent_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">This parser function search for sections splitting inside tex.
The level of sections searched is indicated by sec_level option.
The function calls the parser_hooks of every section block.
When all sections levels are searched the control
pass to parse_instructions().
It returns a list of blocks parsed as tuples.
</pre> 
</div>
</div>
<a id="af4a46e7760e444cd77edf24053eb2cad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4a46e7760e444cd77edf24053eb2cad">&sect;&nbsp;</a></span>parse_special_character()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def texla.Parser.Parser.Parser.parse_special_character </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>parent_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">This function parse special commands like \% or \&amp;.
The mechanism is the same ad special_commands, but options
are not searched.
</pre> 
</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>texla/Parser/Parser.py</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.12
</small></address>
</body>
</html>
